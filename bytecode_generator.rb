## Our humble bytecode format
#
#                                       Stack
# Opcode           Operands     before               after
CALL,            # index, argc  [receiver, args...]  [returned]
PUSH_NUMBER,     # index        []                   [number]
PUSH_STRING,     # index        []                   [string]
PUSH_SELF,       #              []                   [self]
PUSH_NIL,        #              []                   [nil]
PUSH_BOOL,       # 1=t, 0=f     []                   [true or false]
GET_LOCAL,       # index        []                   [value]
SET_LOCAL,       # index        [value]              []
JUMP_UNLESS,     # offset       [condition]          []
JUMP,            # offset       []                   []
ADD,             #              [a, b]               [result]
RETURN = *       #              []                   []
(0..11)

class BytecodeGenerator
  def initialize
    @literals = []
    @locals = []
    @instructions = []
  end
  
  def compile_all(nodes)
    nodes.each do |node|
      node.compile(self)
    end
  end
  
  def number_literal(value)
    # literal_index(1) => 0
    # literal_index("method_name") => 1
    # literal_index(1) => 0
    emit PUSH_NUMBER, literal_index(value)
  end
  
  def string_literal(value)
    emit PUSH_STRING, literal_index(value)
  end
  
  def true_literal
    emit PUSH_BOOL, 1
  end
  
  def false_literal
    emit PUSH_BOOL, 0
  end
  
  def nil_literal
    emit PUSH_NIL
  end
  
  def set_local(name, value_node)
    # a = true
    value_node.compile(self)
    emit SET_LOCAL, local_index(name) # a => 0
  end
  
  def get_local(name)
    
  end
  
  def call(receiver_node, method, argument_nodes)
    # object.method(...)
    if receiver_node
      receiver_node.compile(self)
    # print(...) => self.print(...)
    else
      emit PUSH_SELF
    end

    argument_nodes.each do |node|
      node.compile(self)
    end

    # Static typing example
    # int c;
    if method == "+"
      # emit ADD_TWO_INTS
      emit ADD
      return
    end

    emit CALL, literal_index(method), argument_nodes.size
  end
  
  def if(condition_node, body_node, else_body_node)
    condition_node.compile(self)

    emit JUMP_UNLESS, 0 # <= offset_index of this byte
    offset_index = @instructions.size - 1

    body_node.compile(self)

    # Update w/ number of bytes generated by the body_node
    @instructions[offset_index] = @instructions.size - 1 - offset_index
  end
  
  # Returns the index of the local in the local table
  def local_index(name)
    @locals << name unless @locals.include?(name)
    @locals.index(name)
  end
  
  # Returns the index of the literal in the literal table
  def literal_index(literal)
    @literals << literal unless @literals.include?(literal)
    @literals.index(literal)
  end
  
  # Emit the instruction
  # Eg.:
  #  emit CALL, 1, 10
  # will generate the bytecode
  # 0, 1, 10
  def emit(opcode, *operands)
    @instructions << opcode
    @instructions.concat operands
  end

  # Updates the last generated byte to the size (in bytes) of the generated
  # instructions of a passed blocked.
  #
  # Eg.:
  #   emit JUMP, 0 <---------------------------------v
  #   set_previous_byte_to_size_of do  # Will update 0 to 2.
  #     emit PUSH_NUMBER, 1  # size = 2 bytes <-----------^
  #   end
  def set_previous_byte_to_size_of
    # Get the position of the previous byte in @instructions.
    byte_position = @instructions.size - 1
    # Execute the passed block (everything between do ... end).
    yield
    # Update the previous byte to the number of bytes generated by yield.
    @instructions[byte_position] = @instructions.size - 1 - byte_position
  end
  
  def assemble
    emit RETURN
    
    {
      :literals => @literals,
      :locals => @locals,
      :instructions => @instructions
    }
  end
end
